--- search.cpp
+++ search.cpp
@@ -125,63 +124,36 @@ void perftFast(const ChessPosition& P, int depth, nodecount_t& nNodes)
 	ChessPosition Q = P;
 	nodecount_t orig_nNodes = nNodes;
 
-	const HashKey hk = Q.hk^zobristKeys.zkPerftDepth[depth];
-
-	if (depth == 1) { /* Leaf Node */
-
-		static constexpr uint64_t hkm = - 1ll & ~0xff;
-		const uint64_t k = hk & hkm;
+	// Consult the HashTable:
+	HashKey hk = Q.hk^zobristKeys.zkPerftDepth[depth];
+	std::atomic<PerftTableEntry> *pAtomicRecord = perftTable.getAddress(hk); // get address of atomic record
+	PerftTableEntry retrievedRecord = pAtomicRecord->load(); // Load a copy of the record
+	if (retrievedRecord.Hash == hk) {
+		nNodes += retrievedRecord.count;
+		return;
+	}
 
-		// Consult the HashTable:
-		std::atomic<PerftLeafRecord> *pAtomicRecord = TableOrganiser::perftLeafTable.getAddress(hk);
-		PerftLeafRecord retrievedRecord = pAtomicRecord->load();
-
-		// validate the top 56 bits
-		if (retrievedRecord.k == k) {
-			nNodes += retrievedRecord.count;
-			return;
-		}
-
-		PerftLeafRecord newRecord;
-		newRecord.k = hk & hkm;
-		generateMoves(P, moveList);
-		const int movecount = moveList->moveCount;
+	PerftTableEntry newRecord;
+	newRecord.Hash = hk;
+	newRecord.depth = depth;
+	generateMoves(P, moveList);
+	const int movecount = moveList->moveCount;
 
+	if (depth == 1) { /* Leaf Node*/
 		newRecord.count = movecount;
 		nNodes += movecount;
-
-		do {
-		} while (!pAtomicRecord->compare_exchange_weak(retrievedRecord, newRecord, std::memory_order_relaxed)); // loop until successfully written;
 	} else { /* Branch Node */
-
-		// Consult the HashTable:
-		std::atomic<PerftRecord> *pAtomicRecord =TableOrganiser::perftTable.getAddress(hk);
-		PerftRecord retrievedRecord = pAtomicRecord->load();
-
-		// validate entire hk
-		if (retrievedRecord.Hash == hk) {
-			nNodes += retrievedRecord.count;
-			return;
-		}
-
-		PerftRecord newRecord;
-		newRecord.Hash = hk;
-		newRecord.depth = depth;
-		generateMoves(P, moveList);
-		const int movecount = moveList->moveCount;
-
 		for (int i = 0; i < movecount; i++) {
 			Q = P; // unmake move
 			Q.performMove(moveList[i]).switchSides(); // make move
 			perftFast(Q, depth - 1, nNodes);
 		}
-
 		newRecord.count = nNodes - orig_nNodes; // record RELATIVE increase in nodecount
+	}
 
-		do {
-			// todo: if theirs is bigger than ours, use theirs ?
-		} while (!pAtomicRecord->compare_exchange_weak(retrievedRecord, newRecord, std::memory_order_relaxed)); // loop until successfully written;
-	}
+	do {
+		// if (RetrievedRecord has changed) {} // do something (if we care)
+	} while (!pAtomicRecord->compare_exchange_weak(retrievedRecord, newRecord, std::memory_order_relaxed)); // loop until successfully written;
 }
 
 //// ---------------------------------------------------
