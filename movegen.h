/*

MIT License

Copyright(c) 2016-2025 Judd Niemann

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files(the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions :

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

//////////////////////////////////////////////
// movegen.h								//
// Defines:									//
// Move Generation Functions				//
// Bitboard fill functions					//
//////////////////////////////////////////////

#ifndef _MOVEGEN
#define _MOVEGEN 1
#define _CRT_SECURE_NO_WARNINGS 1

#ifdef _MSC_VER
#include <intrin.h>
#else
#include <x86intrin.h>
#endif

#include <cstdint>

#include <bitset>
#include <iostream>
#include <sstream>
#include <stdexcept>
#include <string>
#include <type_traits>

// Build Options:
#define _USE_HASH 1								// if undefined, entire hash table system will be excluded from build
//
#define _USE_BITSCAN_INSTRUCTIONS 1				// if defined, use x86-64 BSR and BSF instructions (Only available on x86-64)
// #define _USE_POPCNT_INSTRUCTION 1			// if defined, use popcnt instruction (Intel: Nehalem or Higher, AMD: Barcelona or Higher)
// #define _USE_BITTEST_INSTRUCTION 1			// if defined, use the BT instruction (all Intels)

// on gcc, there is a non-standard extension, std::bitset::_Find_first()
// which allows scanning of the first "on" bit, but clang and MSVC don't have it
// also, it is unclear whether this is actually any faster than just looping through all 64 bits
#define _USE_BITSET_FIND_FIRST

// MACRO: BITSET_LOOP(x)
// runs a line of code (x) for each "on" bit in a std::bitset<64>
// this is typically used to get the indices of "on" squares in a BitBoard
// expected: an initialised std::bitset<64> called 'bs' ;-)

#if defined (_USE_BITSET_FIND_FIRST) && defined(_GLIBCXX_BITSET)
#define BITSET_LOOP(x) \
	size_t bit; \
	while ((bit = bs._Find_first()) != 64) { \
		(x); \
		bs.reset(bit); \
	}
#else
#define BITSET_LOOP(x) \
	for (int bit = 0; bit < 64; bit++) { \
		if (bs[bit]) { \
			(x); \
		} \
	}
#endif

#ifndef SMALL_BUFFER_SIZE
#define SMALL_BUFFER_SIZE 64
#endif

#define MOVELIST_SIZE 256
#define CHECKMATE 9999
#define STALEMATE -1

//#define COUNT_MOVEGEN_CPU_CYCLES

namespace juddperft {

class ChessPosition;

using Bitboard = uint64_t;
using nodecount_t = uint64_t;

#ifdef COUNT_MOVEGEN_CPU_CYCLES
extern uint64_t movegen_call_count;
extern uint64_t movegen_total_cycles;
#endif

// ChessMove{} - Compact move format packed into 64 bits
// From and To squares represented by unsigned char square index

struct ChessMove {
	bool blackToMove{false};
	unsigned char piece;
	unsigned char origin;
	unsigned char destination;

	union {
		struct {
			uint32_t moveCount : 8;			// used in the first move of list; indicates how many moves there are
			uint32_t endOfMoveList : 1;		// if set, this marks the end of the move list (not a move)
			uint32_t illegalMove : 1;
			uint32_t unused : 10;
			uint32_t doublePawnMove : 1;
			uint32_t enPassantCapture : 1;
			uint32_t castle : 1;
			uint32_t castleLong : 1;
			uint32_t promoteKnight : 1;
			uint32_t promoteBishop : 1;
			uint32_t promoteRook : 1;
			uint32_t promoteQueen : 1;
			uint32_t capture : 1;
			uint32_t check : 1;				// if set, performing this move will put opponent in check
			uint32_t stalemate : 1;			// if set, performing this move will put opponent in checkmate
			uint32_t checkmate : 1;			// if set, performing this move will result in stalemate
		};
		uint32_t flags{0};
	};
};

/////////////////////////////////////////////
// Move notation styles:
// ---------------------
// LongAlgebraic: e7xf8=Q
// StandardAlgebraic: exf=Q
// CoOrdinate: e7f8q
/////////////////////////////////////////////

enum MoveNotationStyle{
	LongAlgebraic,
	StandardAlgebraic,
	CoOrdinate,
	Diagnostic,
	LongAlgebraicNoNewline
};

class MoveGenerator
{
public:
	static void generateMoves(const ChessPosition & P, ChessMove * pM);
	static bool isInCheck(const ChessPosition& P, bool bIsBlack);

private:
	// White Move-Generation Functions:
	static void generateWhiteMoves(const ChessPosition& P, ChessMove*);
	static inline void addWhiteMove(const ChessPosition& P, ChessMove*& pM, unsigned char fromsquare, unsigned char tosquare, Bitboard F, int32_t piece);
	static Bitboard isWhiteInCheck(const ChessPosition & Z, Bitboard extend = 0);
	static void scanWhiteMoveForChecks(ChessPosition& Q, ChessMove* pM); // detects whether white's proposed move will put black in check or checkmate. updates pM->Check and pM->Checkmate

	// Black Move-Generation Functions:
	static void generateBlackMoves(const ChessPosition& P, ChessMove*);
	static inline void addBlackMove(const ChessPosition& P, ChessMove*& pM, unsigned char fromsquare, unsigned char tosquare, Bitboard F, int32_t piece);

	static Bitboard isBlackInCheck(const ChessPosition & Z, Bitboard extend = 0);
	static void scanBlackMoveForChecks(ChessPosition& Q, ChessMove* pM); // detects whether black's proposed move will put white in check or checkmate. updates pM->Check and pM->Checkmate

	// precomputed move table: contains potential moves (except castling) for every piece on every square
	static uint8_t mvtable[16][64][32]; // piece(16) x origin-square(64) x dest-square(32) = 32k ... (max dest squares = 27 for queen, but using 32 for alignment)

	// function to initialise the move table
	void populate_mvtable();
};

// Print I/O functions:
void printMove(const ChessMove& mv, MoveNotationStyle style = LongAlgebraic, char *pBuffer = nullptr, const ChessMove *movelist = nullptr);
void printMoveList(ChessMove * pMoveList, MoveNotationStyle style = LongAlgebraic, char *pBuffer = nullptr);

// Compound Bitboard Fill operations:
Bitboard fillStraightAttacksOccluded(Bitboard g, Bitboard p);
Bitboard fillDiagonalAttacksOccluded(Bitboard g, Bitboard p);
Bitboard fillKingAttacksOccluded(Bitboard g, Bitboard p);
Bitboard fillKingAttacks(Bitboard g);
Bitboard fillKnightAttacksOccluded(Bitboard g, Bitboard p);

inline Bitboard genBlackAttacks(const ChessPosition& Z);
inline Bitboard genWhiteAttacks(const ChessPosition& Z);

// Fill and Move Bitboard Operations:
Bitboard fillRightOccluded(Bitboard g, Bitboard p);
Bitboard fillLeftOccluded(Bitboard g, Bitboard p);
Bitboard fillUpOccluded(Bitboard g, Bitboard p);
Bitboard fillDownOccluded(Bitboard g, Bitboard p);

Bitboard fillUpRightOccluded(Bitboard g, Bitboard p);
Bitboard fillDownRightOccluded(Bitboard g, Bitboard p);
Bitboard fillDownLeftOccluded(Bitboard g, Bitboard p);
Bitboard fillUpLeftOccluded(Bitboard g, Bitboard p);

Bitboard moveUpSingleOccluded(Bitboard g, Bitboard p);
Bitboard moveUpRightSingleOccluded(Bitboard g, Bitboard p);
Bitboard moveRightSingleOccluded(Bitboard g, Bitboard p);
Bitboard moveDownRightSingleOccluded(Bitboard g, Bitboard p);
Bitboard moveDownSingleOccluded(Bitboard g, Bitboard p);
Bitboard moveDownLeftSingleOccluded(Bitboard g, Bitboard p);
Bitboard moveLeftSingleOccluded(Bitboard g, Bitboard p);
Bitboard moveUpLeftSingleOccluded(Bitboard g, Bitboard p);

Bitboard moveKnight1Occluded(Bitboard g, Bitboard p);
Bitboard moveKnight2Occluded(Bitboard g, Bitboard p);
Bitboard moveKnight3Occluded(Bitboard g, Bitboard p);
Bitboard moveKnight4Occluded(Bitboard g, Bitboard p);
Bitboard moveKnight5Occluded(Bitboard g, Bitboard p);
Bitboard moveKnight6Occluded(Bitboard g, Bitboard p);
Bitboard moveKnight7Occluded(Bitboard g, Bitboard p);
Bitboard moveKnight8Occluded(Bitboard g, Bitboard p);

// some observations / ruminations regarding Bitboards & square indexes
// --------------------------------------------------------------------

// SquareIndex can be thought of as the logarithm(base2) of a Bitboard
// and a Bitboard can be thought of as the result of 2^SquareIndex

// There is no direct way (using bit-shifts, at least) to make an empty bitboard from a square index,
// just as you can't mathematically raise 2 to the power of anything to make it zero.

// a special value is needed to represent "no square":

constexpr int xx = -1; // value for "no square"

// sometimes, you might get something else to represent "no square"
// eg: when getting result from std::bitset::_Find_first(),
// you will get a 64 (= size of the bitset),

// if you treat the square index as some type of unsigned int, then either -1 or 64 will be greater than the highest square (63) ie:
// if (sq > 63) { // no-square ... }

// all the square indexes
enum SquareIndex : unsigned char {
	h1 = 0, g1, f1, e1, d1, c1, b1, a1,
	h2, g2, f2, e2, d2, c2, b2, a2,
	h3, g3, f3, e3, d3, c3, b3, a3,
	h4, g4, f4, e4, d4, c4, b4, a4,
	h5, g5, f5, e5, d5, c5, b5, a5,
	h6, g6, f6, e6, d6, c6, b6, a6,
	h7, g7, f7, e7, d7, c7, b7, a7,
	h8, g8, f8, e8, d8, c8, b8, a8 = 63
};

// all the squares in binary (Bitboard) representation
enum SQUARES : uint64_t {
	H1 = 0x0000000000000001,
	G1 = 0x0000000000000002,
	F1 = 0x0000000000000004,
	E1 = 0x0000000000000008,
	D1 = 0x0000000000000010,
	C1 = 0x0000000000000020,
	B1 = 0x0000000000000040,
	A1 = 0x0000000000000080,

	H2 = 0x0000000000000100,
	G2 = 0x0000000000000200,
	F2 = 0x0000000000000400,
	E2 = 0x0000000000000800,
	D2 = 0x0000000000001000,
	C2 = 0x0000000000002000,
	B2 = 0x0000000000004000,
	A2 = 0x0000000000008000,

	H3 = 0x0000000000010000,
	G3 = 0x0000000000020000,
	F3 = 0x0000000000040000,
	E3 = 0x0000000000080000,
	D3 = 0x0000000000100000,
	C3 = 0x0000000000200000,
	B3 = 0x0000000000400000,
	A3 = 0x0000000000800000,

	H4 = 0x0000000001000000,
	G4 = 0x0000000002000000,
	F4 = 0x0000000004000000,
	E4 = 0x0000000008000000,
	D4 = 0x0000000010000000,
	C4 = 0x0000000020000000,
	B4 = 0x0000000040000000,
	A4 = 0x0000000080000000,

	H5 = 0x0000000100000000,
	G5 = 0x0000000200000000,
	F5 = 0x0000000400000000,
	E5 = 0x0000000800000000,
	D5 = 0x0000001000000000,
	C5 = 0x0000002000000000,
	B5 = 0x0000004000000000,
	A5 = 0x0000008000000000,

	H6 = 0x0000010000000000,
	G6 = 0x0000020000000000,
	F6 = 0x0000040000000000,
	E6 = 0x0000080000000000,
	D6 = 0x0000100000000000,
	C6 = 0x0000200000000000,
	B6 = 0x0000400000000000,
	A6 = 0x0000800000000000,

	H7 = 0x0001000000000000,
	G7 = 0x0002000000000000,
	F7 = 0x0004000000000000,
	E7 = 0x0008000000000000,
	D7 = 0x0010000000000000,
	C7 = 0x0020000000000000,
	B7 = 0x0040000000000000,
	A7 = 0x0080000000000000,

	H8 = 0x0100000000000000,
	G8 = 0x0200000000000000,
	F8 = 0x0400000000000000,
	E8 = 0x0800000000000000,
	D8 = 0x1000000000000000,
	C8 = 0x2000000000000000,
	B8 = 0x4000000000000000,
	A8 = 0x8000000000000000
};

// Common board regions in binary (Bitboard) format
enum Regions : Bitboard {
	RANK1 = 0x00000000000000ff,
	RANK2 = 0x000000000000ff00,
	RANK3 = 0x0000000000ff0000,
	RANK4 = 0x00000000ff000000,
	RANK5 = 0x000000ff00000000,
	RANK6 = 0x0000ff0000000000,
	RANK7 = 0x00ff000000000000,
	RANK8 = 0xff00000000000000,

	FILEA = 0x8080808080808080,
	FILEB = 0x4040404040404040,
	FILEC = 0x2020202020202020,
	FILED = 0x1010101010101010,
	FILEE = 0x0808080808080808,
	FILEF = 0x0404040404040404,
	FILEG = 0x0202020202020202,
	FILEH = 0x0101010101010101,

	RIM	= 0xff818181818181ff,
	UPPER_CENTRE = 0x0000001800000000,
	LOWER_CENTRE = 0x0000000018000000,

	WHITECASTLEZONE				= 0x0000000000000006, // for white to castle, this region must be clear
	WHITECASTLECHECKZONE		= 0x0000000000000006, // for white to castle, the king would not be in check on these squares
	BLACKCASTLEZONE				= 0x0600000000000000, // for black to castle, this region must be clear
	BLACKCASTLECHECKZONE		= 0x0600000000000000, // for black to castle, the king would not be in check on these squares
	WHITECASTLELONGZONE			= 0x0000000000000070, // for white to castle-long, this region must be clear
	WHITECASTLELONGCHECKZONE	= 0x0000000000000030, // for white to castle-long, the king would not be in check on these squares
	BLACKCASTLELONGZONE			= 0x7000000000000000, // for black to castle-long, this region must be clear
	BLACKCASTLELONGCHECKZONE	= 0x3000000000000000, // for black to castle-long, the king would not be in check on these squares
	WHITEOUTPOSTZONE			= 0x0000ffffff000000,
	BLACKOUTPOSTZONE			= 0x000000ffffff0000,

	WHITEQRPOS = 0x0000000000000080,
	WHITEQNPOS = 0x0000000000000040,
	WHITEQBPOS = 0x0000000000000020,
	WHITEQUEENPOS = 0x0000000000000010,
	WHITEKINGPOS = 0x0000000000000008,
	WHITEKBPOS = 0x0000000000000004,
	WHITEKNPOS = 0x0000000000000002,
	WHITEKRPOS = 0x0000000000000001,

	BLACKQRPOS = 0x8000000000000000,
	BLACKQNPOS = 0x4000000000000000,
	BLACKQBPOS = 0x2000000000000000,
	BLACKQUEENPOS = 0x1000000000000000,
	BLACKKINGPOS = 0x0800000000000000,
	BLACKKBPOS  = 0x0400000000000000,
	BLACKKNPOS = 0x0200000000000000,
	BLACKKRPOS = 0x0100000000000000,

	LEFTMASK  = 0xfefefefefefefefe,
	RIGHTMASK = 0x7f7f7f7f7f7f7f7f
};

// Pre-calculated move tables: BitBoards

constexpr Bitboard MoveUp[64] = {
	0x0000000000000100, 0x0000000000000200, 0x0000000000000400, 0x0000000000000800, 0x00000000001000, 0x0000000000002000, 0x0000000000004000, 0x0000000000008000,
	0x0000000000010000, 0x0000000000020000, 0x0000000000040000, 0x0000000000080000, 0x00000000100000, 0x0000000000200000, 0x0000000000400000, 0x0000000000800000,
	0x0000000001000000, 0x0000000002000000, 0x0000000004000000, 0x0000000008000000, 0x00000010000000, 0x0000000020000000, 0x0000000040000000, 0x0000000080000000,
	0x0000000100000000, 0x0000000200000000, 0x0000000400000000, 0x0000000800000000, 0x00001000000000, 0x0000002000000000, 0x0000004000000000, 0x0000008000000000,
	0x0000010000000000, 0x0000020000000000, 0x0000040000000000, 0x0000080000000000, 0x00100000000000, 0x0000200000000000, 0x0000400000000000, 0x0000800000000000,
	0x0001000000000000, 0x0002000000000000, 0x0004000000000000, 0x0008000000000000, 0x10000000000000, 0x0020000000000000, 0x0040000000000000, 0x0080000000000000,
	0x0100000000000000, 0x0200000000000000, 0x0400000000000000, 0x0800000000000000, 0x1000000000000000, 0x2000000000000000, 0x4000000000000000, 0x8000000000000000,
	000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 0000000000000000, 000000000000000000, 000000000000000000, 000000000000000000
};

constexpr Bitboard MoveUpRight[64] = {
	000000000000000000, 0x0000000000000100, 0x0000000000000200, 0x0000000000000400, 0x00000000000800, 0x0000000000001000, 0x0000000000002000, 0x0000000000004000,
	000000000000000000, 0x0000000000010000, 0x0000000000020000, 0x0000000000040000, 0x00000000080000, 0x0000000000100000, 0x0000000000200000, 0x0000000000400000,
	000000000000000000, 0x0000000001000000, 0x0000000002000000, 0x0000000004000000, 0x00000008000000, 0x0000000010000000, 0x0000000020000000, 0x0000000040000000,
	000000000000000000, 0x0000000100000000, 0x0000000200000000, 0x0000000400000000, 0x00000800000000, 0x0000001000000000, 0x0000002000000000, 0x0000004000000000,
	000000000000000000, 0x0000010000000000, 0x0000020000000000, 0x0000040000000000, 0x00080000000000, 0x0000100000000000, 0x0000200000000000, 0x0000400000000000,
	000000000000000000, 0x0001000000000000, 0x0002000000000000, 0x0004000000000000, 0x08000000000000, 0x0010000000000000, 0x0020000000000000, 0x0040000000000000,
	000000000000000000, 0x0100000000000000, 0x0200000000000000, 0x0400000000000000, 0x800000000000000, 0x1000000000000000, 0x2000000000000000, 0x4000000000000000,
	000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 0000000000000000, 000000000000000000, 000000000000000000, 000000000000000000
};

constexpr Bitboard MoveRight[64] = {
	000000000000000000, 0x0000000000000001, 0x0000000000000002, 0x0000000000000004, 0x00000000000008, 0x0000000000000010, 0x0000000000000020, 0x0000000000000040,
	000000000000000000, 0x0000000000000100, 0x0000000000000200, 0x0000000000000400, 0x00000000000800, 0x0000000000001000, 0x0000000000002000, 0x0000000000004000,
	000000000000000000, 0x0000000000010000, 0x0000000000020000, 0x0000000000040000, 0x00000000080000, 0x0000000000100000, 0x0000000000200000, 0x0000000000400000,
	000000000000000000, 0x0000000001000000, 0x0000000002000000, 0x0000000004000000, 0x00000008000000, 0x0000000010000000, 0x0000000020000000, 0x0000000040000000,
	000000000000000000, 0x0000000100000000, 0x0000000200000000, 0x0000000400000000, 0x00000800000000, 0x0000001000000000, 0x0000002000000000, 0x0000004000000000,
	000000000000000000, 0x0000010000000000, 0x0000020000000000, 0x0000040000000000, 0x00080000000000, 0x0000100000000000, 0x0000200000000000, 0x0000400000000000,
	000000000000000000, 0x0001000000000000, 0x0002000000000000, 0x0004000000000000, 0x08000000000000, 0x0010000000000000, 0x0020000000000000, 0x0040000000000000,
	000000000000000000, 0x0100000000000000, 0x0200000000000000, 0x0400000000000000, 0x800000000000000, 0x1000000000000000, 0x2000000000000000, 0x4000000000000000
};

constexpr Bitboard MoveDownRight[64] = {
	000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 0000000000000000, 000000000000000000, 000000000000000000, 000000000000000000,
	000000000000000000, 0x0000000000000001, 0x0000000000000002, 0x0000000000000004, 0x00000000000008, 0x0000000000000010, 0x0000000000000020, 0x0000000000000040,
	000000000000000000, 0x0000000000000100, 0x0000000000000200, 0x0000000000000400, 0x00000000000800, 0x0000000000001000, 0x0000000000002000, 0x0000000000004000,
	000000000000000000, 0x0000000000010000, 0x0000000000020000, 0x0000000000040000, 0x00000000080000, 0x0000000000100000, 0x0000000000200000, 0x0000000000400000,
	000000000000000000, 0x0000000001000000, 0x0000000002000000, 0x0000000004000000, 0x00000008000000, 0x0000000010000000, 0x0000000020000000, 0x0000000040000000,
	000000000000000000, 0x0000000100000000, 0x0000000200000000, 0x0000000400000000, 0x00000800000000, 0x0000001000000000, 0x0000002000000000, 0x0000004000000000,
	000000000000000000, 0x0000010000000000, 0x0000020000000000, 0x0000040000000000, 0x00080000000000, 0x0000100000000000, 0x0000200000000000, 0x0000400000000000,
	000000000000000000, 0x0001000000000000, 0x0002000000000000, 0x0004000000000000, 0x08000000000000, 0x0010000000000000, 0x0020000000000000, 0x0040000000000000
};

constexpr Bitboard MoveDown[64] = {
	000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 0000000000000000, 000000000000000000, 000000000000000000, 000000000000000000,
	0x0000000000000001, 0x0000000000000002, 0x0000000000000004, 0x0000000000000008, 0x00000000000010, 0x0000000000000020, 0x0000000000000040, 0x0000000000000080,
	0x0000000000000100, 0x0000000000000200, 0x0000000000000400, 0x0000000000000800, 0x00000000001000, 0x0000000000002000, 0x0000000000004000, 0x0000000000008000,
	0x0000000000010000, 0x0000000000020000, 0x0000000000040000, 0x0000000000080000, 0x00000000100000, 0x0000000000200000, 0x0000000000400000, 0x0000000000800000,
	0x0000000001000000, 0x0000000002000000, 0x0000000004000000, 0x0000000008000000, 0x00000010000000, 0x0000000020000000, 0x0000000040000000, 0x0000000080000000,
	0x0000000100000000, 0x0000000200000000, 0x0000000400000000, 0x0000000800000000, 0x00001000000000, 0x0000002000000000, 0x0000004000000000, 0x0000008000000000,
	0x0000010000000000, 0x0000020000000000, 0x0000040000000000, 0x0000080000000000, 0x00100000000000, 0x0000200000000000, 0x0000400000000000, 0x0000800000000000,
	0x0001000000000000, 0x0002000000000000, 0x0004000000000000, 0x0008000000000000, 0x10000000000000, 0x0020000000000000, 0x0040000000000000, 0x0080000000000000
};

constexpr Bitboard MoveDownLeft[64] = {
	000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 0000000000000000, 000000000000000000, 000000000000000000, 000000000000000000,
	0x0000000000000002, 0x0000000000000004, 0x0000000000000008, 0x0000000000000010, 0x00000000000020, 0x0000000000000040, 0x0000000000000080, 000000000000000000,
	0x0000000000000200, 0x0000000000000400, 0x0000000000000800, 0x0000000000001000, 0x00000000002000, 0x0000000000004000, 0x0000000000008000, 000000000000000000,
	0x0000000000020000, 0x0000000000040000, 0x0000000000080000, 0x0000000000100000, 0x00000000200000, 0x0000000000400000, 0x0000000000800000, 000000000000000000,
	0x0000000002000000, 0x0000000004000000, 0x0000000008000000, 0x0000000010000000, 0x00000020000000, 0x0000000040000000, 0x0000000080000000, 000000000000000000,
	0x0000000200000000, 0x0000000400000000, 0x0000000800000000, 0x0000001000000000, 0x00002000000000, 0x0000004000000000, 0x0000008000000000, 000000000000000000,
	0x0000020000000000, 0x0000040000000000, 0x0000080000000000, 0x0000100000000000, 0x00200000000000, 0x0000400000000000, 0x0000800000000000, 000000000000000000,
	0x0002000000000000, 0x0004000000000000, 0x0008000000000000, 0x0010000000000000, 0x20000000000000, 0x0040000000000000, 0x0080000000000000, 000000000000000000
};

constexpr Bitboard MoveLeft[64] = {
	0x0000000000000002, 0x0000000000000004, 0x0000000000000008, 0x0000000000000010, 0x00000000000020, 0x0000000000000040, 0x0000000000000080, 000000000000000000,
	0x0000000000000200, 0x0000000000000400, 0x0000000000000800, 0x0000000000001000, 0x00000000002000, 0x0000000000004000, 0x0000000000008000, 000000000000000000,
	0x0000000000020000, 0x0000000000040000, 0x0000000000080000, 0x0000000000100000, 0x00000000200000, 0x0000000000400000, 0x0000000000800000, 000000000000000000,
	0x0000000002000000, 0x0000000004000000, 0x0000000008000000, 0x0000000010000000, 0x00000020000000, 0x0000000040000000, 0x0000000080000000, 000000000000000000,
	0x0000000200000000, 0x0000000400000000, 0x0000000800000000, 0x0000001000000000, 0x00002000000000, 0x0000004000000000, 0x0000008000000000, 000000000000000000,
	0x0000020000000000, 0x0000040000000000, 0x0000080000000000, 0x0000100000000000, 0x00200000000000, 0x0000400000000000, 0x0000800000000000, 000000000000000000,
	0x0002000000000000, 0x0004000000000000, 0x0008000000000000, 0x0010000000000000, 0x20000000000000, 0x0040000000000000, 0x0080000000000000, 000000000000000000,
	0x0200000000000000, 0x0400000000000000, 0x0800000000000000, 0x1000000000000000, 0x2000000000000000, 0x4000000000000000, 0x8000000000000000, 000000000000000000
};

constexpr Bitboard MoveUpLeft[64] = {
	0x0000000000000200, 0x0000000000000400, 0x0000000000000800, 0x0000000000001000, 0x00000000002000, 0x0000000000004000, 0x0000000000008000, 000000000000000000,
	0x0000000000020000, 0x0000000000040000, 0x0000000000080000, 0x0000000000100000, 0x00000000200000, 0x0000000000400000, 0x0000000000800000, 000000000000000000,
	0x0000000002000000, 0x0000000004000000, 0x0000000008000000, 0x0000000010000000, 0x00000020000000, 0x0000000040000000, 0x0000000080000000, 000000000000000000,
	0x0000000200000000, 0x0000000400000000, 0x0000000800000000, 0x0000001000000000, 0x00002000000000, 0x0000004000000000, 0x0000008000000000, 000000000000000000,
	0x0000020000000000, 0x0000040000000000, 0x0000080000000000, 0x0000100000000000, 0x00200000000000, 0x0000400000000000, 0x0000800000000000, 000000000000000000,
	0x0002000000000000, 0x0004000000000000, 0x0008000000000000, 0x0010000000000000, 0x20000000000000, 0x0040000000000000, 0x0080000000000000, 000000000000000000,
	0x0200000000000000, 0x0400000000000000, 0x0800000000000000, 0x1000000000000000, 0x2000000000000000, 0x4000000000000000, 0x8000000000000000, 000000000000000000,
	000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 0000000000000000, 000000000000000000, 000000000000000000, 000000000000000000
};

/*
representations of Knight moves as Bitboards.
They go in a clockwise direction, starting with 2xup, 1xright
eg, if starting square was e4, relative N moves are:

. . . . . . . .
. . . . . . . .
. . . 8 . 1 . .
. . 7 . . . 2 .
. . . . o . . .
. . 6 . . . 3 .
. . . 5 . 4 . .
. . . . . . . .

(could probably also refer to them by their clock positions:
eg 1|2|4|5|7|8|10|11 O-clock ... )

*/

constexpr Bitboard MoveKnight1[64] = {
	000000000000000000, 0x0000000000010000, 0x0000000000020000, 0x0000000000040000, 0x00000000080000, 0x0000000000100000, 0x0000000000200000, 0x0000000000400000,
	000000000000000000, 0x0000000001000000, 0x0000000002000000, 0x0000000004000000, 0x00000008000000, 0x0000000010000000, 0x0000000020000000, 0x0000000040000000,
	000000000000000000, 0x0000000100000000, 0x0000000200000000, 0x0000000400000000, 0x00000800000000, 0x0000001000000000, 0x0000002000000000, 0x0000004000000000,
	000000000000000000, 0x0000010000000000, 0x0000020000000000, 0x0000040000000000, 0x00080000000000, 0x0000100000000000, 0x0000200000000000, 0x0000400000000000,
	000000000000000000, 0x0001000000000000, 0x0002000000000000, 0x0004000000000000, 0x08000000000000, 0x0010000000000000, 0x0020000000000000, 0x0040000000000000,
	000000000000000000, 0x0100000000000000, 0x0200000000000000, 0x0400000000000000, 0x800000000000000, 0x1000000000000000, 0x2000000000000000, 0x4000000000000000,
	000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 0000000000000000, 000000000000000000, 000000000000000000, 000000000000000000,
	000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 0000000000000000, 000000000000000000, 000000000000000000, 000000000000000000
};

constexpr Bitboard MoveKnight2[64] = {
	000000000000000000, 000000000000000000, 0x0000000000000100, 0x0000000000000200, 0x00000000000400, 0x0000000000000800, 0x0000000000001000, 0x0000000000002000,
	000000000000000000, 000000000000000000, 0x0000000000010000, 0x0000000000020000, 0x00000000040000, 0x0000000000080000, 0x0000000000100000, 0x0000000000200000,
	000000000000000000, 000000000000000000, 0x0000000001000000, 0x0000000002000000, 0x00000004000000, 0x0000000008000000, 0x0000000010000000, 0x0000000020000000,
	000000000000000000, 000000000000000000, 0x0000000100000000, 0x0000000200000000, 0x00000400000000, 0x0000000800000000, 0x0000001000000000, 0x0000002000000000,
	000000000000000000, 000000000000000000, 0x0000010000000000, 0x0000020000000000, 0x00040000000000, 0x0000080000000000, 0x0000100000000000, 0x0000200000000000,
	000000000000000000, 000000000000000000, 0x0001000000000000, 0x0002000000000000, 0x04000000000000, 0x0008000000000000, 0x0010000000000000, 0x0020000000000000,
	000000000000000000, 000000000000000000, 0x0100000000000000, 0x0200000000000000, 0x400000000000000, 0x0800000000000000, 0x1000000000000000, 0x2000000000000000,
	000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 0000000000000000, 000000000000000000, 000000000000000000, 000000000000000000
};

constexpr Bitboard MoveKnight3[64] = {
	000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 0000000000000000, 000000000000000000, 000000000000000000, 000000000000000000,
	000000000000000000, 000000000000000000, 0x0000000000000001, 0x0000000000000002, 0x00000000000004, 0x0000000000000008, 0x0000000000000010, 0x0000000000000020,
	000000000000000000, 000000000000000000, 0x0000000000000100, 0x0000000000000200, 0x00000000000400, 0x0000000000000800, 0x0000000000001000, 0x0000000000002000,
	000000000000000000, 000000000000000000, 0x0000000000010000, 0x0000000000020000, 0x00000000040000, 0x0000000000080000, 0x0000000000100000, 0x0000000000200000,
	000000000000000000, 000000000000000000, 0x0000000001000000, 0x0000000002000000, 0x00000004000000, 0x0000000008000000, 0x0000000010000000, 0x0000000020000000,
	000000000000000000, 000000000000000000, 0x0000000100000000, 0x0000000200000000, 0x00000400000000, 0x0000000800000000, 0x0000001000000000, 0x0000002000000000,
	000000000000000000, 000000000000000000, 0x0000010000000000, 0x0000020000000000, 0x00040000000000, 0x0000080000000000, 0x0000100000000000, 0x0000200000000000,
	000000000000000000, 000000000000000000, 0x0001000000000000, 0x0002000000000000, 0x04000000000000, 0x0008000000000000, 0x0010000000000000, 0x0020000000000000
};

constexpr Bitboard MoveKnight4[64] = {
	000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 0000000000000000, 000000000000000000, 000000000000000000, 000000000000000000,
	000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 0000000000000000, 000000000000000000, 000000000000000000, 000000000000000000,
	000000000000000000, 0x0000000000000001, 0x0000000000000002, 0x0000000000000004, 0x00000000000008, 0x0000000000000010, 0x0000000000000020, 0x0000000000000040,
	000000000000000000, 0x0000000000000100, 0x0000000000000200, 0x0000000000000400, 0x00000000000800, 0x0000000000001000, 0x0000000000002000, 0x0000000000004000,
	000000000000000000, 0x0000000000010000, 0x0000000000020000, 0x0000000000040000, 0x00000000080000, 0x0000000000100000, 0x0000000000200000, 0x0000000000400000,
	000000000000000000, 0x0000000001000000, 0x0000000002000000, 0x0000000004000000, 0x00000008000000, 0x0000000010000000, 0x0000000020000000, 0x0000000040000000,
	000000000000000000, 0x0000000100000000, 0x0000000200000000, 0x0000000400000000, 0x00000800000000, 0x0000001000000000, 0x0000002000000000, 0x0000004000000000,
	000000000000000000, 0x0000010000000000, 0x0000020000000000, 0x0000040000000000, 0x00080000000000, 0x0000100000000000, 0x0000200000000000, 0x0000400000000000
};

constexpr Bitboard MoveKnight5[64] = {
	000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 0000000000000000, 000000000000000000, 000000000000000000, 000000000000000000,
	000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 0000000000000000, 000000000000000000, 000000000000000000, 000000000000000000,
	0x0000000000000002, 0x0000000000000004, 0x0000000000000008, 0x0000000000000010, 0x00000000000020, 0x0000000000000040, 0x0000000000000080, 000000000000000000,
	0x0000000000000200, 0x0000000000000400, 0x0000000000000800, 0x0000000000001000, 0x00000000002000, 0x0000000000004000, 0x0000000000008000, 000000000000000000,
	0x0000000000020000, 0x0000000000040000, 0x0000000000080000, 0x0000000000100000, 0x00000000200000, 0x0000000000400000, 0x0000000000800000, 000000000000000000,
	0x0000000002000000, 0x0000000004000000, 0x0000000008000000, 0x0000000010000000, 0x00000020000000, 0x0000000040000000, 0x0000000080000000, 000000000000000000,
	0x0000000200000000, 0x0000000400000000, 0x0000000800000000, 0x0000001000000000, 0x00002000000000, 0x0000004000000000, 0x0000008000000000, 000000000000000000,
	0x0000020000000000, 0x0000040000000000, 0x0000080000000000, 0x0000100000000000, 0x00200000000000, 0x0000400000000000, 0x0000800000000000, 000000000000000000
};

constexpr Bitboard MoveKnight6[64] = {
	000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 0000000000000000, 000000000000000000, 000000000000000000, 000000000000000000,
	0x0000000000000004, 0x0000000000000008, 0x0000000000000010, 0x0000000000000020, 0x00000000000040, 0x0000000000000080, 000000000000000000, 000000000000000000,
	0x0000000000000400, 0x0000000000000800, 0x0000000000001000, 0x0000000000002000, 0x00000000004000, 0x0000000000008000, 000000000000000000, 000000000000000000,
	0x0000000000040000, 0x0000000000080000, 0x0000000000100000, 0x0000000000200000, 0x00000000400000, 0x0000000000800000, 000000000000000000, 000000000000000000,
	0x0000000004000000, 0x0000000008000000, 0x0000000010000000, 0x0000000020000000, 0x00000040000000, 0x0000000080000000, 000000000000000000, 000000000000000000,
	0x0000000400000000, 0x0000000800000000, 0x0000001000000000, 0x0000002000000000, 0x00004000000000, 0x0000008000000000, 000000000000000000, 000000000000000000,
	0x0000040000000000, 0x0000080000000000, 0x0000100000000000, 0x0000200000000000, 0x00400000000000, 0x0000800000000000, 000000000000000000, 000000000000000000,
	0x0004000000000000, 0x0008000000000000, 0x0010000000000000, 0x0020000000000000, 0x40000000000000, 0x0080000000000000, 000000000000000000, 000000000000000000
};

constexpr Bitboard MoveKnight7[64] = {
	0x0000000000000400, 0x0000000000000800, 0x0000000000001000, 0x0000000000002000, 0x00000000004000, 0x0000000000008000, 000000000000000000, 000000000000000000,
	0x0000000000040000, 0x0000000000080000, 0x0000000000100000, 0x0000000000200000, 0x00000000400000, 0x0000000000800000, 000000000000000000, 000000000000000000,
	0x0000000004000000, 0x0000000008000000, 0x0000000010000000, 0x0000000020000000, 0x00000040000000, 0x0000000080000000, 000000000000000000, 000000000000000000,
	0x0000000400000000, 0x0000000800000000, 0x0000001000000000, 0x0000002000000000, 0x00004000000000, 0x0000008000000000, 000000000000000000, 000000000000000000,
	0x0000040000000000, 0x0000080000000000, 0x0000100000000000, 0x0000200000000000, 0x00400000000000, 0x0000800000000000, 000000000000000000, 000000000000000000,
	0x0004000000000000, 0x0008000000000000, 0x0010000000000000, 0x0020000000000000, 0x40000000000000, 0x0080000000000000, 000000000000000000, 000000000000000000,
	0x0400000000000000, 0x0800000000000000, 0x1000000000000000, 0x2000000000000000, 0x4000000000000000, 0x8000000000000000, 000000000000000000, 000000000000000000,
	000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 0000000000000000, 000000000000000000, 000000000000000000, 000000000000000000
};

constexpr Bitboard MoveKnight8[64] = {
	0x0000000000020000, 0x0000000000040000, 0x0000000000080000, 0x0000000000100000, 0x00000000200000, 0x0000000000400000, 0x0000000000800000, 000000000000000000,
	0x0000000002000000, 0x0000000004000000, 0x0000000008000000, 0x0000000010000000, 0x00000020000000, 0x0000000040000000, 0x0000000080000000, 000000000000000000,
	0x0000000200000000, 0x0000000400000000, 0x0000000800000000, 0x0000001000000000, 0x00002000000000, 0x0000004000000000, 0x0000008000000000, 000000000000000000,
	0x0000020000000000, 0x0000040000000000, 0x0000080000000000, 0x0000100000000000, 0x00200000000000, 0x0000400000000000, 0x0000800000000000, 000000000000000000,
	0x0002000000000000, 0x0004000000000000, 0x0008000000000000, 0x0010000000000000, 0x20000000000000, 0x0040000000000000, 0x0080000000000000, 000000000000000000,
	0x0200000000000000, 0x0400000000000000, 0x0800000000000000, 0x1000000000000000, 0x2000000000000000, 0x4000000000000000, 0x8000000000000000, 000000000000000000,
	000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 0000000000000000, 000000000000000000, 000000000000000000, 000000000000000000,
	000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 0000000000000000, 000000000000000000, 000000000000000000, 000000000000000000
};

// Pre-Calculated Move tables: Square-Index (the logarithm of the bitboard versions)

constexpr int MoveUpIndex[64] = {
	8, 9, 10, 11, 12, 13, 14, 15,
	16, 17, 18, 19, 20, 21, 22, 23,
	24, 25, 26, 27, 28, 29, 30, 31,
	32, 33, 34, 35, 36, 37, 38, 39,
	40, 41, 42, 43, 44, 45, 46, 47,
	48, 49, 50, 51, 52, 53, 54, 55,
	56, 57, 58, 59, 60, 61, 62, 63,
	xx, xx, xx, xx, xx, xx, xx, xx
};

constexpr int MoveUpRightIndex[64] = {
	xx, 8, 9, 10, 11, 12, 13, 14,
	xx, 16, 17, 18, 19, 20, 21, 22,
	xx, 24, 25, 26, 27, 28, 29, 30,
	xx, 32, 33, 34, 35, 36, 37, 38,
	xx, 40, 41, 42, 43, 44, 45, 46,
	xx, 48, 49, 50, 51, 52, 53, 54,
	xx, 56, 57, 58, 59, 60, 61, 62,
	xx, xx, xx, xx, xx, xx, xx, xx
};

constexpr int MoveRightIndex[64] = {
	xx, 0, 1, 2, 3, 4, 5, 6,
	xx, 8, 9, 10, 11, 12, 13, 14,
	xx, 16, 17, 18, 19, 20, 21, 22,
	xx, 24, 25, 26, 27, 28, 29, 30,
	xx, 32, 33, 34, 35, 36, 37, 38,
	xx, 40, 41, 42, 43, 44, 45, 46,
	xx, 48, 49, 50, 51, 52, 53, 54,
	xx, 56, 57, 58, 59, 60, 61, 62
};

constexpr int MoveDownRightIndex[64] = {
	xx, xx, xx, xx, xx, xx, xx, xx,
	xx, 0, 1, 2, 3, 4, 5, 6,
	xx, 8, 9, 10, 11, 12, 13, 14,
	xx, 16, 17, 18, 19, 20, 21, 22,
	xx, 24, 25, 26, 27, 28, 29, 30,
	xx, 32, 33, 34, 35, 36, 37, 38,
	xx, 40, 41, 42, 43, 44, 45, 46,
	xx, 48, 49, 50, 51, 52, 53, 54
};

constexpr int MoveDownIndex[64] = {
	xx, xx, xx, xx, xx, xx, xx, xx,
	0, 1, 2, 3, 4, 5, 6, 7,
	8, 9, 10, 11, 12, 13, 14, 15,
	16, 17, 18, 19, 20, 21, 22, 23,
	24, 25, 26, 27, 28, 29, 30, 31,
	32, 33, 34, 35, 36, 37, 38, 39,
	40, 41, 42, 43, 44, 45, 46, 47,
	48, 49, 50, 51, 52, 53, 54, 55
};

constexpr int MoveDownLeftIndex[64] = {
	xx, xx, xx, xx, xx, xx, xx, xx,
	1, 2, 3, 4, 5, 6, 7, xx,
	9, 10, 11, 12, 13, 14, 15, xx,
	17, 18, 19, 20, 21, 22, 23, xx,
	25, 26, 27, 28, 29, 30, 31, xx,
	33, 34, 35, 36, 37, 38, 39, xx,
	41, 42, 43, 44, 45, 46, 47, xx,
	49, 50, 51, 52, 53, 54, 55, xx
};

constexpr int MoveLeftIndex[64] = {
	1, 2, 3, 4, 5, 6, 7, xx,
	9, 10, 11, 12, 13, 14, 15, xx,
	17, 18, 19, 20, 21, 22, 23, xx,
	25, 26, 27, 28, 29, 30, 31, xx,
	33, 34, 35, 36, 37, 38, 39, xx,
	41, 42, 43, 44, 45, 46, 47, xx,
	49, 50, 51, 52, 53, 54, 55, xx,
	57, 58, 59, 60, 61, 62, 63, xx
};

constexpr int MoveUpLeftIndex[64] = {
	9, 10, 11, 12, 13, 14, 15, xx,
	17, 18, 19, 20, 21, 22, 23, xx,
	25, 26, 27, 28, 29, 30, 31, xx,
	33, 34, 35, 36, 37, 38, 39, xx,
	41, 42, 43, 44, 45, 46, 47, xx,
	49, 50, 51, 52, 53, 54, 55, xx,
	57, 58, 59, 60, 61, 62, 63, xx,
	xx, xx, xx, xx, xx, xx, xx, xx
};

constexpr int MoveKnight1Index[64] = {
	xx, 16, 17, 18, 19, 20, 21, 22,
	xx, 24, 25, 26, 27, 28, 29, 30,
	xx, 32, 33, 34, 35, 36, 37, 38,
	xx, 40, 41, 42, 43, 44, 45, 46,
	xx, 48, 49, 50, 51, 52, 53, 54,
	xx, 56, 57, 58, 59, 60, 61, 62,
	xx, xx, xx, xx, xx, xx, xx, xx,
	xx, xx, xx, xx, xx, xx, xx, xx
};

constexpr int MoveKnight2Index[64] = {
	xx, xx, 8, 9, 10, 11, 12, 13,
	xx, xx, 16, 17, 18, 19, 20, 21,
	xx, xx, 24, 25, 26, 27, 28, 29,
	xx, xx, 32, 33, 34, 35, 36, 37,
	xx, xx, 40, 41, 42, 43, 44, 45,
	xx, xx, 48, 49, 50, 51, 52, 53,
	xx, xx, 56, 57, 58, 59, 60, 61,
	xx, xx, xx, xx, xx, xx, xx, xx
};

constexpr int MoveKnight3Index[64] = {
	xx, xx, xx, xx, xx, xx, xx, xx,
	xx, xx, 0, 1, 2, 3, 4, 5,
	xx, xx, 8, 9, 10, 11, 12, 13,
	xx, xx, 16, 17, 18, 19, 20, 21,
	xx, xx, 24, 25, 26, 27, 28, 29,
	xx, xx, 32, 33, 34, 35, 36, 37,
	xx, xx, 40, 41, 42, 43, 44, 45,
	xx, xx, 48, 49, 50, 51, 52, 53
};

constexpr int MoveKnight4Index[64] = {
	xx, xx, xx, xx, xx, xx, xx, xx,
	xx, xx, xx, xx, xx, xx, xx, xx,
	xx, 0, 1, 2, 3, 4, 5, 6,
	xx, 8, 9, 10, 11, 12, 13, 14,
	xx, 16, 17, 18, 19, 20, 21, 22,
	xx, 24, 25, 26, 27, 28, 29, 30,
	xx, 32, 33, 34, 35, 36, 37, 38,
	xx, 40, 41, 42, 43, 44, 45, 46
};

constexpr int MoveKnight5Index[64] = {
	xx, xx, xx, xx, xx, xx, xx, xx,
	xx, xx, xx, xx, xx, xx, xx, xx,
	1, 2, 3, 4, 5, 6, 7, xx,
	9, 10, 11, 12, 13, 14, 15, xx,
	17, 18, 19, 20, 21, 22, 23, xx,
	25, 26, 27, 28, 29, 30, 31, xx,
	33, 34, 35, 36, 37, 38, 39, xx,
	41, 42, 43, 44, 45, 46, 47, xx
};

constexpr int MoveKnight6Index[64] = {
	xx, xx, xx, xx, xx, xx, xx, xx,
	2, 3, 4, 5, 6, 7, xx, xx,
	10, 11, 12, 13, 14, 15, xx, xx,
	18, 19, 20, 21, 22, 23, xx, xx,
	26, 27, 28, 29, 30, 31, xx, xx,
	34, 35, 36, 37, 38, 39, xx, xx,
	42, 43, 44, 45, 46, 47, xx, xx,
	50, 51, 52, 53, 54, 55, xx, xx
};

constexpr int MoveKnight7Index[64] = {
	10, 11, 12, 13, 14, 15, xx, xx,
	18, 19, 20, 21, 22, 23, xx, xx,
	26, 27, 28, 29, 30, 31, xx, xx,
	34, 35, 36, 37, 38, 39, xx, xx,
	42, 43, 44, 45, 46, 47, xx, xx,
	50, 51, 52, 53, 54, 55, xx, xx,
	58, 59, 60, 61, 62, 63, xx, xx,
	xx, xx, xx, xx, xx, xx, xx, xx
};

constexpr int MoveKnight8Index[64] = {
	17, 18, 19, 20, 21, 22, 23, xx,
	25, 26, 27, 28, 29, 30, 31, xx,
	33, 34, 35, 36, 37, 38, 39, xx,
	41, 42, 43, 44, 45, 46, 47, xx,
	49, 50, 51, 52, 53, 54, 55, xx,
	57, 58, 59, 60, 61, 62, 63, xx,
	xx, xx, xx, xx, xx, xx, xx, xx,
	xx, xx, xx, xx, xx, xx, xx, xx
};

// unit test to verify that the lookup tables are in agreement
inline bool testMoveTables()
{
	auto t = [](std::string name, int q, Bitboard bitboard, int sqindex) -> void {
		const bool ok = ((bitboard == 0 && sqindex == xx) || (bitboard == (1ull << sqindex)));
		if (!ok) {
			std::stringstream e;
			e << __func__ << "(): name=" << name << " failed at index " << q << ": " << "index=" << sqindex << " bitboard="<<  std::hex << bitboard;
			throw std::invalid_argument(e.str());
		}
	};

	try {
		for (int q = 0; q < 64; q++) {
			// K
			t("Up", q, MoveUp[q], MoveUpIndex[q]);
			t("UpRight", q, MoveUpRight[q], MoveUpRightIndex[q]);
			t("Right", q, MoveRight[q], MoveRightIndex[q]);
			t("DownRight", q, MoveDownRight[q], MoveDownRightIndex[q]);
			t("Down", q, MoveDown[q], MoveDownIndex[q]);
			t("DownLeft", q, MoveDownLeft[q], MoveDownLeftIndex[q]);
			t("Left", q, MoveLeft[q], MoveLeftIndex[q]);
			t("UpLeft", q, MoveUpLeft[q], MoveUpLeftIndex[q]);

			// N
			t("MoveKnight1", q, MoveKnight1[q], MoveKnight1Index[q]);
			t("MoveKnight2", q, MoveKnight2[q], MoveKnight2Index[q]);
			t("MoveKnight3", q, MoveKnight3[q], MoveKnight3Index[q]);
			t("MoveKnight4", q, MoveKnight4[q], MoveKnight4Index[q]);
			t("MoveKnight5", q, MoveKnight5[q], MoveKnight5Index[q]);
			t("MoveKnight6", q, MoveKnight6[q], MoveKnight6Index[q]);
			t("MoveKnight7", q, MoveKnight7[q], MoveKnight7Index[q]);
			t("MoveKnight8", q, MoveKnight8[q], MoveKnight8Index[q]);
		}
	} catch (const std::invalid_argument& e) {
		std::cout << e.what() << std::endl;
		return false;
	}

	std::cout << __func__ << "() passed" << std::endl;
	return true;
}


// Note : Inline Functions to follow
inline unsigned long getSquareIndex(Bitboard b);

//////// Fill Functions ////////////////////

////////////////////////////////////////////
// Fill-in straight attacks               //
// Note: Fill excludes attacking piece(s) //
////////////////////////////////////////////

inline Bitboard fillStraightAttacksOccluded(Bitboard g, Bitboard p)
{

	Bitboard a;
	a =fillRightOccluded(g, p);
	a |= fillLeftOccluded(g, p);
	a |= fillUpOccluded(g, p);
	a |= fillDownOccluded(g, p);
	a &= ~g; // exclude attacking pieces
	return a;
}

////////////////////////////////////////////
// Fill-in diagonal attacks               //
// Note: Fill excludes attacking piece(s) //
////////////////////////////////////////////
inline Bitboard fillDiagonalAttacksOccluded(Bitboard g, Bitboard p)
{

	Bitboard a;
	a =  fillUpRightOccluded(g, p);
	a |= fillDownRightOccluded(g, p);
	a |= fillDownLeftOccluded(g, p);
	a |= fillUpLeftOccluded(g, p);
	a &= ~g; // exclude attacking piece(s)
	return a;
}

// A = the attacker,
// S = space available to attacker (including capture squares),
// V = victims (capturable squares - ie all enemy units except K and EP squares)

inline Bitboard getDiagonalMoveSquares(Bitboard A, Bitboard S, Bitboard V)
{
	return (fillUpRightOccluded(A, S & ~(RIGHTMASK & (V << 7)))
			| fillDownRightOccluded(A, S & ~(RIGHTMASK & (V >> 9)))
			| fillDownLeftOccluded(A, S & ~(LEFTMASK & (V >> 7)))
			| fillUpLeftOccluded(A, S & ~(LEFTMASK & (V << 9))))
			& ~A;
}

inline Bitboard getStraightMoveSquares(Bitboard A, Bitboard S, Bitboard V)
{
	return (fillRightOccluded(A, S & ~(RIGHTMASK & (V >> 1)))
			| fillLeftOccluded(A, S & ~(LEFTMASK & (V << 1)))
			| fillUpOccluded(A, S & ~(V << 8))
			| fillDownOccluded(A, S & ~(V >> 8)))
			& ~A;
}

////////////////////////////////////////////
// Fill in king attacks                   //
// Note: Fill excludes attacking piece(s) //
////////////////////////////////////////////
inline Bitboard fillKingAttacksOccluded(Bitboard g, Bitboard p)
{
	Bitboard a, b;
	Bitboard t, u;
	a = g; t = g; t <<= 1; t &= LEFTMASK; a |= t;
	b = a; b <<= 8; a |= b; u = a; u >>= 1; u &= RIGHTMASK; a |= u;
	b = a; b >>= 8; a |= b; a &= ~g; a &= p;
	return a;
}

inline Bitboard fillKingAttacks(Bitboard g)
{
	Bitboard a, b;
	Bitboard t, u;
	a = g; t = g; t <<= 1; t &= LEFTMASK; a |= t;
	b = a; b <<= 8; a |= b; u = a; u >>= 1; u &= RIGHTMASK; a |= u;
	b = a; b >>= 8; a |= b; a &= ~g;
	return a;
}

////////////////////////////////////////////
// Fill in knight attacks                 //
// Note: Fill excludes attacking piece(s) //
////////////////////////////////////////////
inline Bitboard fillKnightAttacksOccluded(Bitboard g, Bitboard p)
{
	Bitboard l1 = (g >> 1) & 0x7f7f7f7f7f7f7f7f;
	Bitboard l2 = (g >> 2) & 0x3f3f3f3f3f3f3f3f;
	Bitboard r1 = (g << 1) & 0xfefefefefefefefe;
	Bitboard r2 = (g << 2) & 0xfcfcfcfcfcfcfcfc;
	Bitboard h1 = l1 | r1;
	Bitboard h2 = l2 | r2;
	return p &((h1 << 16) | (h1 >> 16) | (h2 << 8) | (h2 >> 8));

}

inline Bitboard fillKnightAttacks(Bitboard g)
{
	Bitboard l1 = (g >> 1) & 0x7f7f7f7f7f7f7f7f;
	Bitboard l2 = (g >> 2) & 0x3f3f3f3f3f3f3f3f;
	Bitboard r1 = (g << 1) & 0xfefefefefefefefe;
	Bitboard r2 = (g << 2) & 0xfcfcfcfcfcfcfcfc;
	Bitboard h1 = l1 | r1;
	Bitboard h2 = l2 | r2;
	return (h1 << 16) | (h1 >> 16) | (h2 << 8) | (h2 >> 8);
}

inline Bitboard fillUpOccluded(Bitboard g, Bitboard p)
{
	// Note: Fill includes pieces.
	g |= p & (g <<  8);
	p &=     (p <<  8);
	g |= p & (g << 16);
	p &=     (p << 16);
	g |= p & (g << 32);
	return g;
}

inline Bitboard fillDownOccluded(Bitboard g, Bitboard p)
{
	// Note: Fill includes pieces.
	g |= p & (g >>  8);
	p &=     (p >>  8);
	g |= p & (g >> 16);
	p &=     (p >> 16);
	g |= p & (g >> 32);
	return g;
}

inline Bitboard fillLeftOccluded(Bitboard g, Bitboard p)
{
	// Note: Fill includes pieces.
	p &= 0xfefefefefefefefe;
	g |= p & (g << 1);
	p &=     (p << 1);
	g |= p & (g << 2);
	p &=     (p << 2);
	g |= p & (g << 4);
	return g;
}

inline Bitboard fillRightOccluded(Bitboard g, Bitboard p)
{
	// Note: Fill includes pieces.
	p &= 0x7f7f7f7f7f7f7f7f;
	g |= p & (g >> 1);
	p &=     (p >> 1);
	g |= p & (g >> 2);
	p &=     (p >> 2);
	g |= p & (g >> 4);
	return g;
}

inline Bitboard fillUpRightOccluded(Bitboard g, Bitboard p)
{
	// Note: Fill includes pieces.
	p &= 0x7f7f7f7f7f7f7f7f; // left wall
	g |= p & (g <<  7);
	p &=     (p <<  7);
	g |= p & (g << 14);
	p &=     (p << 14);
	g |= p & (g << 28);
	return g;
}

inline Bitboard fillDownRightOccluded(Bitboard g, Bitboard p)
{
	// Note: Fill includes pieces.
	p &= 0x7f7f7f7f7f7f7f7f; // left wall
	g |= p & (g >>  9);
	p &=     (p >>  9);
	g |= p & (g >> 18);
	p &=     (p >> 18);
	g |= p & (g >> 36);
	return g;
}


inline Bitboard fillDownLeftOccluded(Bitboard g, Bitboard p)
{
	// Note: Fill includes pieces.
	p &= 0xfefefefefefefefe; // right wall
	g |= p & (g >> 7);
	p &=     (p >> 7);
	g |= p & (g >> 14);
	p &=     (p >> 14);
	g |= p & (g >> 28);
	return g;
}

inline Bitboard fillUpLeftOccluded(Bitboard g, Bitboard p)
{
	// Note: Fill includes pieces.
	p &= 0xfefefefefefefefe; // right wall
	g |= p & (g << 9);
	p &=     (p << 9);
	g |= p & (g << 18);
	p &=     (p << 18);
	g |= p & (g << 36);
	return g;
}

inline Bitboard moveUpSingleOccluded(Bitboard g, Bitboard p)
{
	return (p & (g << 8));
}

inline Bitboard moveUpRightSingleOccluded(Bitboard g, Bitboard p)
{
	p &= 0x7f7f7f7f7f7f7f7f;
	return (p & (g << 7));
}

inline Bitboard moveRightSingleOccluded(Bitboard g, Bitboard p)
{
	p &= 0x7f7f7f7f7f7f7f7f;
	return (p & (g >> 1));
}

inline Bitboard moveDownRightSingleOccluded(Bitboard g, Bitboard p)
{
	p &= 0x7f7f7f7f7f7f7f7f;
	return (p & (g >> 9));
}

inline Bitboard moveDownSingleOccluded(Bitboard g, Bitboard p)
{
	return (p & (g >> 8));
}

inline Bitboard moveDownLeftSingleOccluded(Bitboard g, Bitboard p)
{
	p &= 0xfefefefefefefefe;
	return (p & (g >> 7));
}

inline Bitboard moveLeftSingleOccluded(Bitboard g, Bitboard p)
{
	p &= 0xfefefefefefefefe;
	return (p & (g << 1));
}

inline Bitboard moveUpLeftSingleOccluded(Bitboard g, Bitboard p)
{
	p &= 0xfefefefefefefefe;
	return (p & (g << 9));
}

inline Bitboard MoveDownLeftRightSingle(Bitboard g)
{
	return	(0xfefefefefefefefe & (g >> 7)) |	// DownLeft
			(0x7f7f7f7f7f7f7f7f & (g >> 9));		// DownRight
}

inline Bitboard MoveUpLeftRightSingle(Bitboard g) {
	return	(0xfefefefefefefefe & (g << 9)) |	// UpLeft
			(0x7f7f7f7f7f7f7f7f & (g << 7));		// UpRight
}

inline Bitboard moveKnight1Occluded(Bitboard g, Bitboard p)
{
	p &= ~0x8080808080808000;
	return (p & (g << 15));
}

inline Bitboard moveKnight2Occluded(Bitboard g, Bitboard p)
{
	p &= ~0xC0C0C0C0C0C0C0C0;
	return (p & (g << 6));
}

inline Bitboard moveKnight3Occluded(Bitboard g, Bitboard p)
{
	p &= ~0x0000C0C0C0C0C0C0;
	return (p & (g >> 10));
}

inline Bitboard moveKnight4Occluded(Bitboard g, Bitboard p)
{
	p &= ~0x0000008080808080;
	return (p & (g >> 17));
}

inline Bitboard moveKnight5Occluded(Bitboard g, Bitboard p)
{
	p &= ~0x0001010101010101;
	return (p & (g >> 15));
}

inline Bitboard moveKnight6Occluded(Bitboard g, Bitboard p)
{
	p &= ~0x0303030303030303;
	return (p & (g >> 6));
}

inline Bitboard moveKnight7Occluded(Bitboard g, Bitboard p)
{
	p &= ~0x0303030303030000;
	return (p & (g << 10));
}

inline Bitboard moveKnight8Occluded(Bitboard g, Bitboard p)
{
	p &= ~0x0101010101000000;
	return (p & (g << 17));
}

inline int popCount(const Bitboard & B)
{
#if defined( _USE_POPCNT_INSTRUCTION) && defined(_WIN64) && defined(_MSC_VER)
	return static_cast<int>(__popcnt64(B));
#else
	// This routine comes from:
	// Knuth, TAoCP Vol 4: Fascicle 1, (no. 62)
	Bitboard A;
	A = B - ((B >> 1) & 0x5555555555555555);
	A = (A & 0x3333333333333333) +
			((A >> 2) & 0x3333333333333333);
	A = (A + (A >> 4)) & 0x0f0f0f0f0f0f0f0f;
	return static_cast<int>((A * 0x0101010101010101) >> 56);
#endif
}

inline unsigned long getSquareIndex(Bitboard b)
{
	enum BitscanMethod {
		DeBruijn,
		CompilerSpecificIntrinsic,
		StdBitset
	};

	static constexpr BitscanMethod bitscanMethod = DeBruijn;

	if constexpr (bitscanMethod == DeBruijn) {
		// see (https://chessprogramming.wikispaces.com/BitScan)
		// credit: Kim Walisch, Gerd Isenberg et al.

		const Bitboard db64 = 0x03f79d71b4cb0a89;

		const int tbl[64] = {
			0, 47,  1, 56, 48, 27,  2, 60,
			57, 49, 41, 37, 28, 16,  3, 61,
			54, 58, 35, 52, 50, 42, 21, 44,
			38, 32, 29, 23, 17, 11,  4, 62,
			46, 55, 26, 59, 40, 36, 15, 53,
			34, 51, 20, 43, 31, 22, 10, 45,
			25, 39, 14, 33, 19, 30,  9, 24,
			13, 18,  8, 12,  7,  6,  5, 63
		};

		// BitScanForward:
		return tbl[(((b ^ (b - 1)) * db64) >> 58)];
	} else if (bitscanMethod == CompilerSpecificIntrinsic) {

		unsigned long n;
#if defined(_MSC_VER)
		_BitScanForward64(&n, b);
#elif defined(__GNUC__) || defined(__clang__)
		n = __builtin_ctzll(b);
#endif
		return n;

	} else if (bitscanMethod == StdBitset) {
		std::bitset<64> bs(b);

#if defined(_GLIBCXX_BITSET)
		return bs._Find_first();
#else

#endif

	}
}

// getFirstAndLastPiece()
// Note: starts from Bottom Right (H1 / bit 0), ends Top-Left (A8 / bit 63)
inline void getFirstAndLastPiece(const Bitboard& B, unsigned long& a, unsigned long& b)
{

#if defined(_USE_BITSCAN_INSTRUCTIONS)
	// perform Bitscans to determine start and finish squares;
#if defined(_MSC_VER)
	// Important: a and b must be initialised first !
	_BitScanReverse64(&b, B);
	_BitScanForward64(&a, B);
#elif defined(__GNUC__) || defined(__clang__)
	b = 63 - __builtin_clzll(B);
	a = __builtin_ctzll(B);
#endif

#else

	// alternative method for non-x86-64, using DeBruijn Multiplication:
	// see (https://chessprogramming.wikispaces.com/BitScan)
	// credit: Kim Walisch, Gerd Isenberg et al.

	const BitBoard db64 = 0x03f79d71b4cb0a89;

	const int tbl[64] = {
		0, 47,  1, 56, 48, 27,  2, 60,
		57, 49, 41, 37, 28, 16,  3, 61,
		54, 58, 35, 52, 50, 42, 21, 44,
		38, 32, 29, 23, 17, 11,  4, 62,
		46, 55, 26, 59, 40, 36, 15, 53,
		34, 51, 20, 43, 31, 22, 10, 45,
		25, 39, 14, 33, 19, 30,  9, 24,
		13, 18,  8, 12,  7,  6,  5, 63
	};

	// BitScanForward:
	a = tbl[(((B ^ (B - 1)) * db64) >> 58)];

	// BitScanReverse:
	BitBoard A = B;
	A |= A >> 1;
	A |= A >> 2;
	A |= A >> 4;
	A |= A >> 8;
	A |= A >> 16;
	A |= A >> 32;
	b = tbl[((A * db64) >> 58)];

#endif
}

// utility function to generate the move lookup index tables from the move lookup bitboard tables
inline bool genIdxTbl(std::string name, const Bitboard *bb)
{
	std::cout << "const int " << name << "[64] = {\n";
	for (int r = 0; r < 64; r+= 8) {
		std::cout << "\t";
		for (int f = 0; f < 8; f++) {
			int q = r | f;

			if (bb[q] == 0) {
				std::cout << "xx";
			} else {
				std::cout << getSquareIndex(bb[q]);
			}
			if (q != 63) {
				std::cout << ", ";
			}
		}
		std::cout << "\n";
	}
	std::cout << "};" << std::endl;
	return true;
}

} // namespace juddperft

#endif // _MOVEGEN
